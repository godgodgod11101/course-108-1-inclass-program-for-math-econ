---
title: "20190926 class"
author: "jacky wang"
date: "2020/8/2"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(reticulate)

# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
```

**設定**

按小齒輪－＞按chunk output in console－＞彈出寫code視窗
chunk output in console讓console可編譯Python（>>> Python code）
在console打exit，就會回復原狀（> R code）





# dictionary

元素以 key: value 成對定義的**集合**（set）

```{python}

setA={"a", "c", 2, 3, 7}
setB={
  1: "a", 
  2: "b", 
  3: 2, 
  4: 3, 
  5: 7
}    # key can be intger

setC={
  "1": "a", 
  "2": "b", 
  "3": 2, 
  "4": 3, 
  "5": 7
}    # key can be string

```

```{python}

setB[2]
setC["2"]

# key is immutable and hashable! 

```

```{python}

dictionaryA={"name": "Mary", "id": "A28374", "grade": 77}
dictionaryA

```

```{python}

dictionaryA["name"] = "Jacky"
dictionaryA["name"]    # dictionary is mutable! 

```

## practice

有5個人的
  學號為172、214、322、425、517
  姓名為小明、大雄、胖虎、小新、大白
  成績為80、60、90、70、50
  
1. 創造名為grade的dictionary物件存下這些資訊。
2. 取出成績的value。
```{python}

dic_grade = {
  "studentID": ["172", "214", "322", "425", "517"], 
  "name": ["Min", "Bear", "Tiger", "New", "White"], 
  "grade": [80, 60, 90, 70, 50]
}

dic_grade["grade"]

```

取出"小明"及80
```{python}

dic_grade["name"][0]
dic_grade["grade"][0]

```

3. 使用dictionary comprehension創造一個dictionary物件，其 key: value 為 姓名: 成績。
```{python}

{dic_grade["name"][0]: dic_grade["grade"][0]}

{dic_grade["name"][index]: dic_grade["grade"][index] for index in [0, 1, 2, 3, 4]}
# {dic_grade["name"][index]: dic_grade["grade"][index] for index in [0:4]}    # wrong!

```

# dictionary

tuple也可以用來當key
```{python}

sparseMatrix = {
  (0, 0): 3, 
  (0, 2): -2, 
  (0, 3): 11,
  (1, 1): 9, 
  (2, 1): 7, 
  (3, 3): -5
}
print(sparseMatrix)

```
稀疏矩陣（sparse matrix）：只記錄矩陣「非零」的位置，佔較小記憶體空間。

```{python}

sparseMatrix[(3, 3)]

```



# mutable, immutable, hashable

```{python}

# tuple is immutable

tupleA = (3, 4, 5)
print(tupleA)

# tupleA[1] = 8    # TypeError: 'tuple' object does not support item assignment

```

```{python}

# list is mutable

listA = [3, 4, 5]
print(listA)

listA[1] = 8
listA

```

```{python}

# dictionary is mutable

dictA = {
  "name": "Jack", 
  "height": 183, 
  "weight": 90, 
  "age": 31, 
  "hobby": ["swim", "work out", "coding"]
}
dictA

dictA["name"] = "Jason"
dictA

```

## practice

```{python}

listA=[2,7,5,-2,13]
listA

# change element 1 (index = 0) to 0

listA[0] = 0
listA

# change element 2 (index = 1) to ("a", "b")

listA[1] = ("a", "b")
listA

```

# list copy

```{python}

originalList=[1,2,"a"]

# three ways to copy

# definition copy
definitionCopy=originalList    # = in Python is equal to <- in R

# slice copy
sliceCopy=originalList[:]    # XXX[:]: select all
sliceCopy2=originalList.copy()

originalList
definitionCopy
sliceCopy
sliceCopy2

```

定義式的複製下，definitionCopy與originalList會有連動關係。
```{python}

originalList=[1,2,"a"]
definitionCopy=originalList
print(definitionCopy)
print(originalList)

definitionCopy[1]="change1"
print(definitionCopy)
print(originalList)

```

```{python}

originalList[1]="change2"
print(definitionCopy)
print(originalList)

```

切割式的複製，不具有完全的連動關係。
```{python}

originalList=[1,2,"a"]
sliceCopy=originalList[:]
print(sliceCopy)
print(originalList)

sliceCopy[1]="change1"
print(sliceCopy)
print(originalList)

```

```{python}

originalList[1]="change2"
print(sliceCopy)
print(originalList)

```

## shallow copy

```{python}

treeA = [1, 2, ["a", "b"]]
treeACopy = treeA.copy()

treeA
treeACopy

```

更動「根」部位：不會產生連動
```{python}

treeA[0] = "change1"

treeA
treeACopy

```

更動「枝」部位：產生連動
```{python}

treeA[2][0] = "change2"

treeA
treeACopy

```

## deep copy

```{python}

original = [[0, 1], "Jack"]
shallowCopy = original[:]

import copy    # import copy module

deepCopy = copy.deepcopy(original)

print(original)
print(shallowCopy)
print(deepCopy)

```

```{python}

original[1] = "change1"

print(original)
print(shallowCopy)    # shallowCopy doesn't change 
print(deepCopy)

```

```{python}

original[0][0] = "change2"

print(original)
print(shallowCopy)    # shallowCopy has changed! 
print(deepCopy)

```





# CH2 物件運算

operation與method的不同處，
在於method是直接作用在物件上，而operation不是。

operation：針對一個情境去呈現結果
```{python}

a=2; b=3; c=5

a+b
a>b
(a>b or a<c)

a; b; c    # doesn't change

```

method：直接作用在一個物件上
```{python}

# add an element 5 (integer) into listA 

listA=[2,3,"b"]
listA+[5]    # operation
listA    # doesn't change

listA.append(5)    # method
listA    # listA has changed! Because it is mutable. 

```
只有method「有可能」「直接改變」物件內容！

```{python}

stringA="Hello"
stringA.upper()    # method: returns a string where all characters are in upper case
stringA    # stringA doesn't change. Because it is immutable.

```

# operation

```{python}

3+3
3-2
3*2
3/2
3//2    # modulo operation
3**4    # 3 to the power of 4

```
modulo operation：計算一個數除以另一個數的餘數

```{python}

# logical operation

3>4
3>=4
3==3
3!=4

```

## practice

1. 計算numList每個值+3
2. 判斷numList每個值是否>10

```{python}

numList=[3,2,11,43]
# numList + 3    # wrong!

[numList[i] + 3 for i in range(4)]

[numList[i] > 10 for i in range(4)]

```

# operation

但list可以和list做+（增加元素）
```{python}

numList=[3,2,11,43]
numList

numList + [3]
numList + ["a","b"]

```

list可以和整數做*（複製多次接在一起）
```{python}

numList*2
2*numList

```




