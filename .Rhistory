# Chunk 29
import requests
response = requests.get(url="https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ&category=3")
# Chunk 30
print(response.status_code)    # 200 means no problem
if response.status_code == requests.codes.ok:   # remember *:*
print("OK!")
# Chunk 31
danceInfo = response.json()
type(danceInfo)
# Chunk 32
danceInfo[1].keys()
reticulate::repl_python()
danceInfo[1].keys()
quit
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
# Chunk 2
listJ = ["a","b","c"]
listJCopy = listJ.copy()    # shallow copy
# by method
listJ.append("d")
listJ    # listJ has changed!
# by operation
listJCopy + ["d"]
listJCopy
# Chunk 3
listJCopy = listJCopy + ["d"]
listJCopy
# Chunk 4
listJ = ["a","b","c"]
# listJ.append("d", "e")
listJ.extend(["d", "e", "f"])
listJ
# Chunk 5
listJ = ["a","b","c"]
[listJ.append(iterable) for iterable in ["d", "e", "f"]]
print(listJ)
# list.append() returns None, but listJ still changed.
# also
listJ = ["a","b","c"]
for iterable in ["d", "e", "f"]:
listJ.append(iterable)    # <expression> must be indented!
print(listJ)
# Chunk 6
listJ = ["Jacky", ["Calculus", 70], ["Accounting", 81]]
listJ.append(["Economics", 77])
listJ
# Chunk 7
listJ = ["Jacky", ["Calculus", 70], ["Accounting", 81], ["Economics", 77]]
listD = ["Dawn", ["Calculus", 55], ["Accounting", 90], ["Economics", 65]]
listJ.extend(listD)
listJ
len(listJ)
# Chunk 8
x = [1, 2, 3]
x.insert(2, "hello")    # insert(index, object)
print(x)
x.insert(0, "start")
print(x)
x.insert(-1, "last")    # insert object *before* index
print(x)
# Chunk 9
x=['start', 1, 2, 'hello', 'last', 3]
print(x)
x.__delitem__(0)
x
# Chunk 10
x=['start', 1, 2, 'hello', 'last', 3]
print(x)
del x[:3]
x
del x    # delete object
# Chunk 11
y="hello"
# del y[1:4]    # TypeError: 'str' object does not support item deletion
y_list = list(y)
del y_list[1:4]
y = "".join(y_list)
y
# Chunk 12
y=[1,2,3,5,3,4]
print(y)
y.remove(3)    # list.remove(value)
print(y)
# Chunk 13
z = [[3, 5], [2, 9], [2, 3], [4, 1], [3, 2]]
len(z)
print(z)
z.sort()    # lexicographic sorting
print(z)
z.sort(reverse = True)    # descending order
print(z)
z.sort(key = sum, reverse = True)    # sorting z based on sum function
print(z)
# Chunk 14
listJ = ["Helen", "Alex", "John", "Mark","Alex"]
listJ.index("Alex")    # only find the first one
# Chunk 15
index_list = []
len(listJ)
for iterable in [0, 1, 2, 3, 4]:
if listJ[iterable] == "Alex":    # must be indented!
index_list.append(iterable)    # must be indented!
print(index_list)
# Chunk 16
listJ = [1,2,3,3,3,3,4,7]
listJ.count(3)    # count(value)
listJ.count(4)
# Chunk 17
tupleA=(1,3,2,3)
tupleA.count(3)
tupleA.index(3)
# Chunk 18
list1 = [2]
set1 = {2}
tupleAWrong = (2)    # atomic type
tupleA=(2,)
list1; set1; tupleAWrong; tupleA
# Chunk 19
x = set([1, 2, 3, 1, 3, 5])
x
x.add(6)    # add 1 element
x
x.update({7, 8, 10})    # add more element
x
# Chunk 20
x = set([1, 2, 3, 5, 6, 7, 8, 10])
x.remove(1)
x
x.difference({7, 8, 10})
x    # x doesn't change
x.difference_update({7, 8, 10})
x    # x has changed
# Chunk 21
dictionaryA={
"date": [2001, 2002, 2003],
"amount": [21000, 33000, 45880]
}
dictionaryA
dictionaryA["quantity"]=[100, 200, 300]
dictionaryA
# Chunk 22
dictionaryA["date"]    # check
# Chunk 23
dictionaryA.keys()
# Chunk 24
dictionaryA.values()
# Chunk 25
dictionaryA.items()   # display like tuple: (key, value)
# Chunk 26
"date" in dictionaryA    # operation
"color" in dictionaryA
# Chunk 27
dictionaryA.get("date")
dictionaryA.get("color")    # no output
dictionaryA.get("color", "out of boundaries")
# Chunk 28
# reticulate::conda_install(
#   envname = "classEnvironment",
#   packages = "requests"
# )
# Chunk 29
import requests
response = requests.get(url="https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ&category=3")
# Chunk 30
print(response.status_code)    # 200 means no problem
if response.status_code == requests.codes.ok:   # remember *:*
print("OK!")
# Chunk 31
danceInfo = response.json()
type(danceInfo)
# Chunk 32
danceInfo[1].keys()
reticulate::repl_python()
danceInfo[1].keys()
quit
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
# Chunk 2
listJ = ["a","b","c"]
listJCopy = listJ.copy()    # shallow copy
# by method
listJ.append("d")
listJ    # listJ has changed!
# by operation
listJCopy + ["d"]
listJCopy
# Chunk 3
listJCopy = listJCopy + ["d"]
listJCopy
# Chunk 4
listJ = ["a","b","c"]
# listJ.append("d", "e")
listJ.extend(["d", "e", "f"])
listJ
# Chunk 5
listJ = ["a","b","c"]
[listJ.append(iterable) for iterable in ["d", "e", "f"]]
print(listJ)
# list.append() returns None, but listJ still changed.
# also
listJ = ["a","b","c"]
for iterable in ["d", "e", "f"]:
listJ.append(iterable)    # <expression> must be indented!
print(listJ)
# Chunk 6
listJ = ["Jacky", ["Calculus", 70], ["Accounting", 81]]
listJ.append(["Economics", 77])
listJ
# Chunk 7
listJ = ["Jacky", ["Calculus", 70], ["Accounting", 81], ["Economics", 77]]
listD = ["Dawn", ["Calculus", 55], ["Accounting", 90], ["Economics", 65]]
listJ.extend(listD)
listJ
len(listJ)
# Chunk 8
x = [1, 2, 3]
x.insert(2, "hello")    # insert(index, object)
print(x)
x.insert(0, "start")
print(x)
x.insert(-1, "last")    # insert object *before* index
print(x)
# Chunk 9
x=['start', 1, 2, 'hello', 'last', 3]
print(x)
x.__delitem__(0)
x
# Chunk 10
x=['start', 1, 2, 'hello', 'last', 3]
print(x)
del x[:3]
x
del x    # delete object
# Chunk 11
y="hello"
# del y[1:4]    # TypeError: 'str' object does not support item deletion
y_list = list(y)
del y_list[1:4]
y = "".join(y_list)
y
# Chunk 12
y=[1,2,3,5,3,4]
print(y)
y.remove(3)    # list.remove(value)
print(y)
# Chunk 13
z = [[3, 5], [2, 9], [2, 3], [4, 1], [3, 2]]
len(z)
print(z)
z.sort()    # lexicographic sorting
print(z)
z.sort(reverse = True)    # descending order
print(z)
z.sort(key = sum, reverse = True)    # sorting z based on sum function
print(z)
# Chunk 14
listJ = ["Helen", "Alex", "John", "Mark","Alex"]
listJ.index("Alex")    # only find the first one
# Chunk 15
index_list = []
len(listJ)
for iterable in [0, 1, 2, 3, 4]:
if listJ[iterable] == "Alex":    # must be indented!
index_list.append(iterable)    # must be indented!
print(index_list)
# Chunk 16
listJ = [1,2,3,3,3,3,4,7]
listJ.count(3)    # count(value)
listJ.count(4)
# Chunk 17
tupleA=(1,3,2,3)
tupleA.count(3)
tupleA.index(3)
# Chunk 18
list1 = [2]
set1 = {2}
tupleAWrong = (2)    # atomic type
tupleA=(2,)
list1; set1; tupleAWrong; tupleA
# Chunk 19
x = set([1, 2, 3, 1, 3, 5])
x
x.add(6)    # add 1 element
x
x.update({7, 8, 10})    # add more element
x
# Chunk 20
x = set([1, 2, 3, 5, 6, 7, 8, 10])
x.remove(1)
x
x.difference({7, 8, 10})
x    # x doesn't change
x.difference_update({7, 8, 10})
x    # x has changed
# Chunk 21
dictionaryA={
"date": [2001, 2002, 2003],
"amount": [21000, 33000, 45880]
}
dictionaryA
dictionaryA["quantity"]=[100, 200, 300]
dictionaryA
# Chunk 22
dictionaryA["date"]    # check
# Chunk 23
dictionaryA.keys()
# Chunk 24
dictionaryA.values()
# Chunk 25
dictionaryA.items()   # display like tuple: (key, value)
# Chunk 26
"date" in dictionaryA    # operation
"color" in dictionaryA
# Chunk 27
dictionaryA.get("date")
dictionaryA.get("color")    # no output
dictionaryA.get("color", "out of boundaries")
# Chunk 28
# reticulate::conda_install(
#   envname = "classEnvironment",
#   packages = "requests"
# )
# Chunk 29
import requests
response = requests.get(url="https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ&category=3")
# Chunk 30
print(response.status_code)    # 200 means no problem
if response.status_code == requests.codes.ok:   # remember *:*
print("OK!")
# Chunk 31
danceInfo = response.json()
type(danceInfo)
# Chunk 32
danceInfo[1].keys()
reticulate::repl_python()
danceInfo[1].keys()
danceInfo[1].values()
quit
View(y_list)
py$dict_finStatement
View(py$dict_finStatement)
py$dict_finStatement
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
py_available()
py$dict_finStatement
repl_python()
dict_finStatement
exit
py$dict_finStatement
View(py$dict_finStatement)
repl_python()
dict_finStatement
quit
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
View(py$dict_finStatement)
py$dict_finStatement[["撟游漲"]]
reticulate::repl_python()
dict_finStatement.keys()
dict_finStatement.get('營業利益（損失）')
dict_finStatement
dict_finStatement.get('營業利益（損失）').values
dict_finStatement.get('營業利益（損失）')
dict_finStatement.get('營業利益（損失）').values
dict_finStatement.get('營業利益（損失）').values()
dict_finStatement.keys()
dict_finStatement.get('公司名稱')
list(dict_finStatement.get('公司名稱').values())
list(dict_finStatement.get('公司名稱').values())[1]
dict_finStatement.get('營業利益（損失）').values()
list(dict_finStatement.get('營業利益（損失）').values())
profit = dict_finStatement.get('營業利益（損失）').values()
list(dict_finStatement.get('公司名稱').values())
[list(dict_finStatement.get('公司名稱').values())[i] for i in range(len(profit)) if profit[i] < 0]
list(dict_finStatement.get('公司名稱').values())[1]
dict_finStatement.get('營業利益（損失）').values()
profit = list(dict_finStatement.get('營業利益（損失）').values())
[list(dict_finStatement.get('公司名稱').values())[i] for i in range(len(profit)) if profit[i] < 0]
quit
repl_python()
for i in range(len(profit)) if profit[i] < 0:
list(dict_finStatement.get('公司名稱').values())[i]
for i in range(len(profit)) if profit[i] < 0:
list(dict_finStatement.get('公司名稱').values())[i]
{for i in range(len(profit)) if profit[i] < 0:
list(dict_finStatement.get('公司名稱').values())[i]}
profit = list(dict_finStatement.get('營業利益（損失）').values())
[list(dict_finStatement.get('公司名稱').values())[i] for i in range(len(profit)) if profit[i] < 0]
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
reticulate::repl_python()
quit
reticulate::repl_python()
dict_finStatement
dict_finStatement.keys()
dict_finStatement.get()
dict_finStatement.get('營業利益（損失）')
dict_finStatement.get('營業利益（損失）').values()
list(dict_finStatement.get('營業利益（損失）').values())
list(dict_finStatement.get('營業利益（損失）').values())[1]
list(dict_finStatement.get('公司名稱').values())[1]
[list(dict_finStatement.get('公司名稱').values())[i] for i in range(len(list(dict_finStatement.get('營業利益（損失）').values()))) if list(dict_finStatement.get('營業利益（損失）').values())[i] < 0]
list(dict_finStatement.get('公司名稱').values())[0]
quit
repl_python()
response
response.json()
response.json()[1]
quit
repl_python()
danceInfo[1].values
danceInfo[1].values()
list(danceInfo[1].values())
list(danceInfo[1].values())[3]
4
list(danceInfo[1].values())[4]
list(danceInfo[1].values())[4][0]
list(list(danceInfo[1].values())[4][0])
list(list(danceInfo[1].values())[4][0]).items()
list(list(danceInfo[1].values())[4][0])
list(danceInfo[1].values())[4][0]
list(danceInfo[1].values())[4][0].items()
list(danceInfo[1].values())[4][0].get('location')
exit
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
repl_python()
int
quit
repl_python()
quit
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
# 設定要使用的python（可能因要使用不同版本的python而路徑有所改變）
use_python("D:\\anaconda3\\envs\\classEnvironment\\python.exe", required = T)
# 在名為classEnvironment的沙盒下寫python
use_condaenv("classEnvironment", required = T)
repl_python()
quit
repl_python()
type(dict_finStatement)
dict_finStatement.keys()
dict_finStatement['營業利益（損失）']
dict_finStatement['營業利益（損失）'].values()
list(dict_finStatement['營業利益（損失）'].values())
profit = list(dict_finStatement['營業利益（損失）'].values())
list(dict_finStatement[''公司名稱''].values())
list(dict_finStatement['公司名稱'].values())
copName = list(dict_finStatement['公司名稱'].values())
[copName[i] for i in range(len(copName)) if profit < 0]
[copName[i] for i in range(len(copName)) if profit[i] < 0]
copName = list(dict_finStatement['公司名稱'].values())
profit = list(dict_finStatement['營業利益（損失）'].values())
[copName[i] for i in range(len(copName)) if profit[i] < 0]
def lossFirmList(dict_finSta):
copName = list(dict_finSta['公司名稱'].values())
profit = list(dict_finSta['營業利益（損失）'].values())
return [copName[i] for i in range(len(copName)) if profit[i] < 0]
lossFirmList(dict_finStatement)
lossFirmList(dict_finStatement)
quit
repl_python()
del lossFirmList()
del lossFirmList
lossFirmList(dict_finStatement)
def lossFirmList(dict_finSta):
copName = list(dict_finSta['公司名稱'].values())
profit = list(dict_finSta['營業利益（損失）'].values())
return [copName[i] for i in range(len(copName)) if profit[i] < 0]
lossFirmList(dict_finSta=dict_finStatement)
quit
